# Block Rendering & Interaction Pipeline

This document walks through the pieces that turn a persisted **`BlockRenderStructure`** into an interactive, nestable grid of blocks. The focus is on rendering, layout manipulation, and end‑user interactions so a new teammate can quickly orient themselves.

---

## 1. Data Model at a Glance

- **`BlockRenderStructure`** (generated by the API) is the master description of a surface. It contains:
  - `layoutGrid`: top level grid dimensions and the list of widget items (`id`, breakpoints, dimensions).
  - `components`: map of component nodes keyed by component id. Each node stores the component `type`, raw `props`, `bindings`, and optional slot metadata.
- **`BlockTree`** contains the payload (`payload.data`) and reference collections (`references`) that populate component props.

Other helper types you’ll see include:
- **`TreeCtx`** (defined in `components/feature-modules/blocks/components/render.tsx`) – a simple wrapper that injects payload data and references down into binding utilities.
- **`BlockComponentNode`** – the shape of a component item, as defined by the OpenAPI schema (`block.interface.ts`).

---

## 2. Rendering Pipeline (`components/.../render.tsx`)

### 2.1 `RenderBlock`
`RenderBlock` is the composition root for any rendered surface.

1. **Context prep**
   ```ts
   const ctx = useMemo<TreeCtx>(() => ({
     payload: tree.root.block.payload.data,
     references: tree.root.references ?? {},
   }), [tree]);
   ```
   The context is passed to binding helpers (see §4).

2. **Grid options + state**
   - The component keeps a local `currentDisplay` state. This mirrors the incoming `display` object so the UI can react to client-side deletions before a new server payload exists.
   - `buildGridOptions` (see below) converts the structure into a `GridStackOptions` object.

3. **Providers**
   - `GridProvider` instantiates a `GridStack` instance and exposes helpers (`addWidget`, `removeWidget`, `saveOptions`, …).
   - `GridContainerProvider` mounts the DOM container and keeps track of element → widget mappings.
   - `LayoutExporterInitializer` registers a callback so consumers can re-export the current layout (`useBlockLayoutExporter`).
   - `BlockElementsRenderer` hosts the actual React components through `RenderElementProvider`.

4. **Deletion flow**
   - `handleComponentDelete` updates `currentDisplay` via `removeComponentFromDisplay`, pruning the deleted node and any nested descendants from the structure.
   - `BlockElementsRenderer` passes a contextual right-click menu down to each rendered widget (see §3.3). When triggered, it calls `removeWidget(id)` (removing the GridStack item) and `handleComponentDelete(componentId)` (keeping `currentDisplay` in sync).

### 2.2 `buildGridOptions` & `buildWidgetForComponent`

These helpers are responsible for translating the declarative render tree into GridStack widgets.

- **`buildGridOptions`** iterates over top-level `layoutGrid.items`, calling `buildWidgetForComponent` for each.
- **`buildWidgetForComponent`**:
  1. Fetches the corresponding `BlockComponentNode`.
  2. Runs `evalVisible` to honour the optional visibility expression.
  3. Uses `applyBindings` to merge dynamic data into the node’s props.
  4. Validates props against the Zod schema stored in the element registry (`block.registry.tsx`).
  5. Produces a `GridStackWidget` (id, coordinates, dimensions, serialized payload).
  6. Calls `buildSubGrid` if the node exposes slots. This boots another grid configuration, enabling nested layouts.

### 2.3 `buildSubGrid`

`buildSubGrid` inspects a node’s slots, resolves any stored layout overrides (`slotLayout`), and recursively calls `buildWidgetForComponent` for each nested item. The returned `GridStackOptions` is attached to the parent widget as `subGridOpts`.

### 2.4 Widget Creation Helpers (`createWidget`, `pickRect`, `createDefaultRect`)

These are small utilities that keep widget serialization consistent across top-level and nested grids.

---

## 3. Rendering Individual Components

### 3.1 Component Registry (`block.registry.tsx`)

Every rendered block type is declared here with:
- A unique `type` (string constant).
- Zod `schema` used for runtime validation.
- A React `component` implementation (the actual UI).
- Descriptive metadata (`name`, `description`, etc.).

This registry is consumed by `RenderElementProvider`, so adding a new component type is as simple as extending this file.

### 3.2 `RenderElementProvider`

`RenderElementProvider` bridges GridStack widgets with React components:

1. It iterates over the `Map` of serialized widgets supplied by `GridProvider`.
2. Each widget’s `content` string is parsed back into `{ type, props, componentId, ... }`.
3. The element metadata is fetched from the registry, props validated against its Zod schema, and the component rendered.
4. The component is cloned into the correct DOM container using `createPortal`.

**Transform and wrapping hooks**
- `transformProps` lets callers inject extra props (e.g., drag handles, playground-specific callbacks).
- `wrapElement` (added for context menus) allows the caller to wrap the rendered component in additional UI chrome without touching the underlying block implementation.

### 3.3 Context Menu Wrapper (`BlockElementsRenderer`)

`BlockElementsRenderer` (inside `components/.../render.tsx`) uses `wrapElement` to add a Radix context menu around every rendered block:

```tsx
<ContextMenu>
  <ContextMenuTrigger asChild>
    <div className="h-full w-full">{element}</div>
  </ContextMenuTrigger>
  <ContextMenuContent>
    <ContextMenuItem variant="destructive" onSelect={handleDelete}>
      Delete block
    </ContextMenuItem>
  </ContextMenuContent>
</ContextMenu>
```

`handleDelete` removes the widget from GridStack and prunes it from the local `BlockRenderStructure`. This keeps the UI responsive even before new server state arrives.

---

## 4. Binding Data to Components (`util/block.binding.ts`)

`applyBindings` takes a `BlockComponentNode` and a `TreeCtx`, returning component props with all bindings resolved.

- **Data path bindings** (`source.type === "DataPath"`) traverse `payload.data` via JSON pointer semantics (`jsonpointer` library).
- **Reference slot bindings** pull from `ctx.references` and can either:
  - Provide raw block references (for nested/inline rendering).
  - Project summaries of linked entities (with optional field selection).
- **Computed bindings** are currently placeholders (set as `undefined`) but provide a hook for future derived values.

The helper mutates a shallow copy of the node’s props, ensuring we never mutate the canonical definition.

---

## 5. Persisting Layout Changes (`util/block.layout.ts`)

`buildDisplayFromGridState` converts the runtime GridStack state back into a `BlockRenderStructure`. It’s used when exporting/saving the layout.

High-level steps:
1. Clone the existing `components` map.
2. Walk the serialized widget tree (including subgrids) and:
   - Update `layoutGrid.items` with current positions/sizes.
   - Rebuild slot ordering (`slots`) and layout metadata (`slotLayout`) for components that host nested content.
3. Return a new `BlockRenderStructure`, ready to be persisted.

Supporting helpers (`widgetToRect`, `createSlotAccumulator`, `ensureSlot`) keep the shape consistent with the input schema.

---

## 6. Surface Chrome & Interactions (`components/.../BlockSurface.tsx`)

The `BlockSurface` component is the interactive wrapper shown around each panel in the playground. Key behaviours:

- **Keyboard shortcuts** (`Ctrl/Cmd+K`, `Ctrl/Cmd+E`, `/`) are scoped to the *active* surface, tracked via a simple global registry (`activeSurfaceId`, `hoveredSurfaceId`).
- **Header actions**:
  - Toggle between “Display” and “Form” representations.
  - Trigger slash menu / quick action palette.
  - Invoke dropdown menu actions (e.g., duplicate, delete). These hook into callbacks provided by callers (`quickActions`, `onDelete`).
- **Context menu**: `BlockSurface` instances also expose a right-click Radix menu so the same actions are reachable without touching the header.

Nested block regions, like the “Add nested block” affordance, simply render another `PanelGridWorkspace` (see demo component below).

---

## 7. Playground Demo (`components/.../demo/block-demo.tsx`)

The playground showcases the full pipeline and provides state-management utilities that real screens can mirror.

### Highlights

- **`PlaygroundProvider`** keeps an array of `PlaygroundBlock` entries and exposes helper methods for insertion, duplication, deletion, and layout syncing.
- **`PanelWidget`** adapts `RenderBlock` for each panel:
  - Passes through block-specific metadata (title, description, badge).
  - Supplies slash menu items and quick actions (duplicate/delete) to `BlockSurface`.
  - Hooks the delete action into both `removeWidget` (GridStack removal) and the provider’s `removePanel`.
- **`PanelLayoutSync`** listens for `change`, `dragstop`, and `resizestop` GridStack events to persist layout changes back into React state via `applyLayouts`.
- **Factories (`createContactBlock`, etc.)** produce sample `BlockTree` structures so the playground has realistic data to render.

---

## 8. Interaction Summary

| Action | Where It Lives | What Happens |
| --- | --- | --- |
| Delete nested block | Context menu provided by `BlockElementsRenderer` | `removeWidget(id)` + `removeComponentFromDisplay` |
| Delete panel | `BlockSurface` dropdown/context menu (via quick actions) | `removeWidget(panelId)` + `PlaygroundProvider.removePanel` |
| Duplicate panel | `quickActionsFor` in playground | Clones block structure before inserting into state |
| Export layout | `LayoutExporterInitializer` / `useBlockLayoutExporter` | Calls `gridStack.save` and rehydrates via `buildDisplayFromGridState` |
| Binding update | `applyBindings` | Props are re-evaluated every render, so the view reflects current payload data |

---

## 9. Extending The System

When adding new behaviour:

1. **New component type** → update `block.registry.tsx` with schema + component and ensure props are handled in `applyBindings`.
2. **Custom interactions** → wrap rendered components using `RenderElementProvider`’s `transformProps`/`wrapElement`.
3. **Persisted layout changes** → use `buildDisplayFromGridState` to save edits and supply the updated structure to `RenderBlock`.
4. **Playground utilities** → mirror the patterns in `PlaygroundProvider` to keep GridStack and React state in sync.

With these pieces in mind, a newcomer should be able to:
- Trace how a block definition becomes a live widget.
- Understand how GridStack is configured and synchronised.
- Extend the system with new block types or interactions without breaking existing behaviour.

